## Больше, Чем Просто Типизация JS Библиотек

Первая версия Typescript увидела свет
[больше 6 лет назад](https://devblogs.microsoft.com/typescript/announcing-typescript-1-0). За это время язык повзрослел
и медленно, но верно становится стандартом Javascript разработки. Slack, AirBnB, Lyft и многие другие компании выбирают
Typescript для разработки новых приложений как для браузера, так и NodeJS сервисов. Конечно, в любом подходе всегда
есть свои плюсы и минусы. Один из минусов заключается в том, что многие npm библиотеки всё ещё написаны на Javascript.
Статический анализ не может вывести типы для таких библиотек и все преимущества типизированного кода исчезают. К
счастью, у Typescript есть способ решения таких проблем, позволивший ему заработать популярность с самых первых версий.

### Объявления Типов

Для любого Javascript модуля мы можем создать файл с расширением `d.ts`, в котором легко описать интерфейс данного
модуля. Typescript анализатор будет использовать объявленные типы данных из d.ts файла каждый раз, когда мы делаем
импорт соответствующего JS модуля. Такой подход позволяет легко наполнить проект контекстом во время миграции на
Typescript. На практике это выглядит достаточно тривиально, и пример ниже показывает суть подхода:

```javascript
// sample.js

export const pageSize = 25;
export const pageSizes = [25, 50, 100];
export const getOffset = (page, pageSize) => page * pageSize;
```

(простой JS модуль `sample.js` может выглядеть так)

Мы можем сделать импорт `sample.js` в некотором Typescript модуле. Но ни автодополнение, ни вывод типов — ничего этого
работать не будет. Каждому объекту из импорта будет присвоен тип `any`, что не сильно поможет в дальнейшем. Для того,
чтобы описать, какой API представляет наш Javascript модуль, мы пользуемся соглашением и создаем файл с объявлением
типов:

```typescript
// sample.d.ts

export const pageSize: number;
export const pageSizes: [number, number, number];
export const getOffset: (page: number, pageSize: number) => number;
```

(`.d.ts` объявления — это стандартный способ для описания типов соответствующего JS модуля)

Важный момент — Typescript оперирует объявлениями типов, так как не может получить эту информацию из Javascript кода.
Если, к примеру, мы удалим `export const pageSizes = [25, 50, 100]` из модуля `sample.js`, это никак не повлияет на
поведение Typescript анализатора. В результате мы получим ошибку уже в процессе выполнения скрипта. Получается, что
разработчики должны следить за этим и держать файлы с объявлениями типов синхронизованными с исходным кодом модуля. С
другой стороны, данный подход позволяет пользоваться всеми преимуществами статического анализа без необходимости
переписывать весь Javascript код приложения.

В интернете можно найти множество реализаций типизации JS модулей. Можно найти нужный пример среди тысяч d.ts файлов в
репозитории
[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). Это репозиторий, который используют разработчики,
чтобы публиковать объявления типов для библиотек, опубликованных в npm. Также можно найти ответы в
[официальной документации](https://www.typescriptlang.org/docs/handbook/2/type-declarations.html), я не буду заострять
внимание на этом. Расскажу про наш случай.

### Наша Javascript Библиотека

Во всех наших продуктах мы используем библиотеку UI компонентов, которую написали сами внутри компании. Она отметила
уже 12 версий. Есть план мигрировать на веб-компоненты, но пока мы в самом начале пути. С другой стороны, мы используем
Typescript в новых приложениях. Проблема в том, что когда команда начинает писать новый функционал (или рефакторить
старый, мигрируя код на Typescript), приходится восстанавливать часть объявлений типов для UI библиотеки. Так, в каждом
репозитории у нас появились небольшие кусочки описаний типов для UI компонентов. Мы решили, что пора создать отдельный
npm пакет и описать все возможности UI библиотеки в одном месте, и вот почему:

- Мы будем подключать этот пакет при инициализации нового репозитория, что позволит контролировать версию и упростит
  рефакторинг при обновлении.
- Перестанем дублировать один и тот же код снова и снова.
- Объявления типов будут выступать в качестве дополнительной документации к библиотеке. Ведь выбирать метод из
  подсказок **IntelliSense** гораздо удобнее, чем идти на сайт с описанием нужного компонента и копировать имя метода.

### Что Же Не Так?

Так что же тут особенного? Дело в том, что мы добавляем на страницу глобальный объект для того, чтобы использовать
функционал UI библиотеки. То есть, она доступна глобально. В то же время, у нас есть наборы константных значений
(список иконок, цвета тегов, типы данных в клетке таблицы и так далее), которые мы используем в наших приложениях.
Обычно это набор заданных значений, с помощью которого мы можем стилизовать тот или иной компонент. Например, мы можем
отрисовать один из несколько типов кнопок:

```typescript
// lists/button.ts

export enum ButtonType {
  Primary = "ui-primary",
  Secondary = "ui-secondary",
  Danger = "ui-danger"
}
```

(цвет, размер и шрифт кнопки зависят от значения, которое мы передали)

Было бы неплохо сложить все такие константы и списки значений в одно место с объявлениями типов. Выходит, что в
результате мы должны получить не просто файл с объявлением типов всех сущностей UI библиотеки, а целый пакет, который
бы полностью отображал состояние библиотеки на конкретный момент времени.
Объединяя всё, сказанное выше, наша цель состояла из трех пунктов:

1.  Описать глобальный объект `ui`, который доступен всегда без необходимости объявлять импорт библиотеки.
2.  Все типы данных из библиотеки также должны быть доступны всегда без необходимости объявлять импорт библиотеки.
3.  Дополнительно мы хотим иметь возможность объявить импорт для констант и других доступных значений из UI библиотеки
    (всё это не является частью глобальной переменной `ui`). В этом случае не должно быть никаких конфликтов с пунктами
    1 и 2.

Кажется, что это несложно, ведь так? Мы просто создаем `d.ts` модуль, прописываем все объявления типов для нашей
библиотеки и... ок, мы не можем объявлять реальный код (константы, объекты и т.п.) внутри `d.ts` файлов. Хорошо. Тогда
мы создадим реальный Typescript модуль и положим все этим списки и интерфейсы туда. Затем, мы... как мы тогда объявим
нашу глобальную переменную?..

День поисков не дал подходящего примера для такого случая. StackOverflow переполнен вопросами относительно концепта
`.d.ts против .ts`, и ничего похожего на задачу, которую я решаю, найти не удалось. Всё, что оставалось, это пойти
читать официальную документацию и пробовать разные варианты. Вот что получилось в результате.

### Начнем С Нуля

Итак, у нас ничего нет. Создадим новый репозиторий и напишем интерфейсы, добавим константы, enum списки и другие
значения, которые поддерживает наша библиотека компонентов. Здесь и ниже я буду приводить примеры в упрощенном виде,
так как в этой статье я делаю акцент на задаче, которую решаю, а не на конкретной реализации того или иного интерфейса.
Итак, представим, что наша библиотека содержит компонент нотификации — это простое модальное окно с текстом и, может
быть, кнопками. Один из вариантов описания методов для вызова такого компонента может выглядеть следующим образом:

```typescript
// interfaces/notification.ts

import { ButtonType } from "../lists/button";

export interface NotificationButtonConfig {
  text?: string;
  type?: ButtonType;
}

export interface Notification {
  info(text: string, buttons?: NotificationButtonConfig[]): void;
  warning(text: string, buttons?: NotificationButtonConfig[]): void;
  error(text: string, buttons?: NotificationButtonConfig[]): void;
}
```

(Мы описали объект с методами вызова разных видов нотификаций, состоящих из текста и кнопок)

В качестве одного из параметров мы используем enum-список `ButtonType`, который уже объявляли раньше:

```typescript
// lists/button.ts

export enum ButtonType {
  Primary = "ui-primary",
  Secondary = "ui-secondary",
  Danger = "ui-danger"
}
```

(мы подсвечиваем кнопку в определенном стиле в зависимости от типа)

Теперь рассмотрим самый простой случай. Наша UI библиотека предоставляет API для работы с компонентами. Значит у нас
должен быть доступ к глобальному объекту библиотеки без необходимости делать импорт чего-либо:

```typescript
// example/application/moduleNoImport.ts

ui.notification.info("Document has been saved!");
```

(мы вызываем окно нотификации с текстом с помощью глобального объекта `ui`)

Как мы можем сделать объект `ui` доступным глобально? Добавим его в глобальную область видимости:

```typescript
// index.ts

import { UiLib } from "./interfaces/ui";

declare global {
  let ui: UiLib;
}
```

(мы объявили новый глобальный объект)

Интерфейс `UiLib` здесь содержит описания для всего API, которое поддерживает наша UI библиотека. В нашей упрощенной
реализации, здесь объявлены методы для отображения нотификаций на странице:

```typescript
// interfaces/ui.ts

import { Notification } from "./notification";

export interface UiLib {
  notification: Notification;
}
```

(разные типы уведомлений собраны в интерфейсе Notification, как мы могли увидеть выше)

И на этом можно закончить со случаем, который мы рассматриваем. Остается только настроить наш только что приготовленный
npm пакет. Мы попросим Typescript разнести код и объявления типов в разные директории, а также явно укажем сохранять
объявления типов при компиляции в Javascript. Часть нашего `tsconfig.json` будет выглядеть следующим образом:

```json
{
  "compilerOptions": {
    "declaration": true,
    "declarationDir": "dist/",
    "outDir": "dist/es"
  }
}
```

Последним шагом мы укажем правильные пути в нашем `package.json`:

```json
{
  "main": "dist/es/index.js",
  "types": "dist/index.d.ts"
}
```

(не забудьте добавить стадию компиляции из Typescript при публикации пакета)

Теперь точно все. Мы можем установить новый пакет в очередном репозитории, указать в `tsconfig.json` путь для
объявлений типов (так как наш npm пакет не попадает в директорию по-умолчанию `@types`) и увидеть как всё работает!

### А Как Же Пользоваться Значениями?

Усложним задачу. У нас есть enum-список `ButtonType`, и мы хотим им воспользоваться. Для этого нам нужно сделать импорт
значения, например вот так:

```typescript
// example/application/moduleWithImport.ts

import { UiCore } from "ui-types-package";

const showNotification = (message: string): void =>
  ui.notification.info(message, [
    { text: "OK", type: UiCore.ButtonType.Danger }
  ]);
```

(мы хотим показать модальное окно с большой красной кнопкой)

Отмечу, что здесь **UiCore** по факту является неймспейсом для всех констант, интерфейсов, списков — то есть для
всех сущностей, которые содержит и поддерживает наша UI библиотека. Таким образом, нам не нужно думать о том, как
назвать очередной интерфейс. `Notification` звучит очень абстрактно, и нужен префикс, чтобы понять, кому принадлежит
тот или иной объект. С другой стороны `UiCore.Notification` дает полное понимание принадлежности к библиотеке
компонентов. Создавать неймспейс необязательно, я лишь нашел этот подход удобным для того, чтобы сгруппировать все вещи
в одном месте.

~~Между `UiLib` и `UiCore` есть разница: первый является описанием API глобальной переменной, которую добавляет на страницу
наша библиотека компонентов. Второе же это всё, что включает в себя~~

На данный момент мы не можем сделать импорт для `UiCore` из нашего пакета с типами. У нас просто нет экспорта. Исправим
этот момент. Для начала объявим неймспейс:

```typescript
// namespaces/core.ts

import * as notificationInterfaces from "../interfaces/notification";
import * as buttonLists from "../lists/button";

export namespace UiCore {
  export import NotificationButtonConfig = notificationInterfaces.NotificationButtonConfig;

  export import ButtonType = buttonLists.ButtonType;
}
```

(мы используем композитный оператор экспорта для того, чтобы создать псевдоним объекта внутри неймспейса)

Мы делаем экспорт всех доступных объектов внутри неймспейса с помощью синтаксиса `export import`. Всё что нам осталось
сделать, это дать доступ к нашему свежему неймспейсу извне. Для этого у нас уже есть главный модуль пакета `index.ts`.
Добавим в него одну строчку с экспортом `UiCore`:

```typescript
// index.ts

import { UiLib } from "./interfaces/ui";

export { UiCore } from "./namespaces/core";

declare global {
  let ui: UiLib;
}
```

(мы делаем экспорт UiCore и теперь он доступен для импорта в других проектах)

Два простых шага позволили нам добиться необходимого результата. Теперь мы можем сделать импорт UiCore в модуле нашего
приложения и использовать все возможности UI компонентов нашей библиотеки. Или можем придумать варианты использования,
которые не покрыты текущей реализацией. Например, в нашем примере мы использовали значение `ButtonType.Danger`, чтобы
создать уведомление с кнопкой, окрашенной в красный цвет. Что, если мы захотим использовать `ButtonType` как тип
параметра для очередной функции? Мы можем сделать импорт UiCore. Но зачем?

### Закрываем Краевые Случаи

Мы не собираемся пользоваться каким-то определенным значением и будем использовать `UiCore.ButtonType` для объявления
типа параметров. Значит нет смысла объявлять импорт для `UiCore`. На данный момент такой способ не будет работать,
так как мы не добавили `UiCore` в глобальную область видимости. Например, мы не сможем написать такой метод:

```typescript
// example/application/moduleWithType.ts

const showNotificationWithButton = (
  buttonText: string,
  buttonType: UiCore.ButtonType
): void =>
  ui.notification.info("hello world!", [
    { text: buttonText, type: buttonType }
  ]);
```

(TS2503: Cannot find namespace 'UiCore')

Нам нужно объявить `UiCore` глобально. И здесь мы приходим к истории о том, что нельзя просто так взять существующий
неймспейс и сделать его ре-экспорт в глобальной области видимости. Трюк заключается в том, что придется создать новый
неймспейс с таким же именем (в нашем случае `UiCore`) и объявить все объекты, которые мы собрали в одном месте, второй
раз. Хорошая новость: необязательно собирать каждый интерфейс из отдельного модуля. Можно просто вывести наш глобальный
неймспейс из существующего:

```typescript
// index.ts

import { UiCore as _UiCore } from "./namespaces/core";
import { UiLib } from "./interfaces/ui";

export { _UiCore as UiCore };

declare global {
  namespace UiCore {
    export type NotificationButtonConfig = _UiCore.NotificationButtonConfig;

    export type ButtonType = _UiCore.ButtonType;
  }

  let ui: UiLib;
}
```

(мы создаем типы объектов из существующего неймспейса с помощью оператора создания псевдонимов типа)

Первым шагом мы переименуем импорт `UiCore` для того, чтобы избежать конфликта имён. Далее мы поправим имя в экспорте
для того, чтобы всё осталось на своих местах. Наконец, мы создаем новый неймспейс в глобальной области видимости и
создаем псевдонимы типов для каждой сущности. Может показаться, что мы дублируем код. Отчасти это так, но на самом деле
мы получаем разные сущности. Сравните:

```typescript
// UiCore в глобальной области видимости
export type ButtonType = buttonLists.ButtonType;

// UiCore, содержащий ссылки на реальные значения
export import ButtonType = lButton.ButtonType;
```

(синтаксис отличается для каждого случая)

Неймспейс в глобальной области видимости использует синтаксис
[псевдонима типа](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases).
Такой подход не работает, когда нам нужно использовать реальное значение переменной. Вместо этого, мы делаем экспорт
объектов в нашем реальном неймспейсе с помощью композитного оператора `export import`. Таким образом, мы собираем все
интерфейсы, константы, типы данных под одним именем. Всё API нашей Javascript библиотеки собрано в одном месте и опыт её
использования не зависит от того, объявит разработчик импорт или нет.

Такой трюк заставляет следить за тем, чтобы объявить очередной объект в двух местах, ведь технически, у нас два
независимых неймспейса. С другой стороны, это позволяет покрыть все возможные варианты использования библиотеки типов в
проекте. В результате разработчики получают готовые объявления типов для UI компонентов и могут использовать глобальный
объект `ui` также, как и в Javascript модулях — без необходимости импорта чего-либо из библиотеки типов. Также отпадает
необходимости создавать одни и те же константы снова и снова. Теперь все они уже объявлены и лежат в одном месте. Если
вам нужна красная кнопка — вы объявляете импорт и присваиваете нужное значение. При этом остальной код продолжает
работать как обычно. Мы создавали объявления типов на Typescript 3 версии. В 4 версии появился специальный синтаксис,
который работает похожим способом и не противоречит нашей реализации. Вы можете написать
`import type { UiCore } from "ui-types-package"` и всё будет работать, как раньше.

### В Заключении

Вы можете найти тысячи примеров того, как создавать объявления типов для вашей Javascript библиотеки. Я постарался
рассказать редкий случай, когда необходимо создать не только объявления типов, но также сохранить реальные значения
полей, с которыми может работать API библиотеки. Неважно, используете вы глобальный объект или объявляете импорт для
нужной переменной — опыт работы с таки пакетом не изменится. Идея заключается в том, чтобы создать два похожих
неймспейса с одинаковым именем: неймспейс для экспорта, содержащий реальные переменные и данные, и глобальную копию с
помощью оператора создания псевдонима типов. Имена, указанные в статье, легко заменить на то, что нужно в вашей
реализации.

Полный исходный код примеров можно найти [здесь](https://github.com/n0th1ng-else/typescript-types-complex-example).
