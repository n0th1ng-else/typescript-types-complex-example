## Больше, Чем Просто Типизация JS Библиотек

Первая публичная версия Typescript увидела свет больше 8 лет назад. За это время язык повзрослел и медленно, но верно
становится стандартом Javascript разработки. Сейчас, в 2021 году, всё больше компаний выбирают Typescript для
разработки новых приложений как для браузера, так и NodeJS сервисов. Конечно, в любом подходе всегда есть плюсы и минусы.
Один из минусов заключается в том, что многие NPM библиотеки написаны на Javascript. Таким образом, статический анализ
не может вывести типы для таких библиотек и все преимущества типизированного кода сходят на нет. К счастью, у Typescript
есть способ решения таких проблем, позволивший ему заработать популярность с самых первых версий.

### Объявления Типов

Для любого Javascript модуля мы можем создать файл с расширением `d.ts`, в котором легко описать интерфейс данного
модуля. Typescript анализатор будет использовать объявленные типы данных из d.ts модуля каждый раз, когда мы делаем
импорт соответствующего JS модуля. Такой подход позволяет легко наполнить проект контекстом в период миграции на
Typescript. На практике это выглядит достаточно тривиально, и пример ниже показывает суть подхода:

```javascript
// sample.js

export const pageSize = 25;
export const pageSizes = [25, 50, 100];
export const getOffset = (page, pageSize) => page * pageSize;
```

(простой JS модуль `sample.js` может выглядеть так)

Мы можем сделать импорт `sample.js` в нашем Typescript модуле. Но ни авто дополнение, ни вывод типов — ничего этого
работать не будет. Каждому объекту из импорта модуля будет выведен тип `any`, что не сильно поможет в дальнейшем.
Для того, чтобы описать, какой API представляем наш Javascript модуль, мы пользуемся соглашением и создаем файл с
объявлением типов:

```typescript
// sample.d.ts

export const pageSize: number;
export const pageSizes: [number, number, number];
export const getOffset: (page: number, pageSize: number) => number;
```

(`.d.ts` объявления — это стандартный способ для описания типов соответствующего JS модуля)

Важный момент — Typescript оперируем объявлениями типов для JS файлов. Таким образом, если мы удалим
`export const pageSizes = [25, 50, 100]` из модуля `sample.js`, это никак не повлияет на анализатор кода. В результате
мы получим ошибку уже в процессе выполнения скрипта. Получается, что разработчики должны следить за этим и держать
файлы с объявлениями типов синхронизованными с исходным кодом модуля. С другой стороны, данный подход позволяет
пользоваться всеми преимуществами статического анализа без необходимости переписывать весь Javascript код приложения.

В интернете можно найти множество примеров типизации JS модулей. Можно найти пример среди тысяч d.ts файлов в
репозитории
[DefinitelyTyped](https://github.com/DefinitelyTyped/DefinitelyTyped). Это репозиторий, который используют разработчики,
чтобы публиковать объявления типов для библиотек, опубликованных в NPM. Также можно найти ответы в
[официальной документации](https://www.typescriptlang.org/docs/handbook/2/type-declarations.html), я не буду заострять
внимание на этом.

### Наша Javascript Библиотека

Во всех наших продуктах мы используем библиотеку UI компонентов, которую написали сами внутри компании. Она отметила
уже 12 версий. Есть план мигрировать на веб-компоненты, но пока мы в самом начале пути. С другой стороны, мы используем
Typescript в новых приложениях. Проблема в том, что когда команда начинает писать новый функционал (или рефакторить
старый, мигрируя на Typescript), приходится восстанавливать часть объявлений типов для объектов UI библиотеки. Так, в
каждом репозитории у нас появились небольшие куски описаний типов для наших UI компонентов. Мы решили, что пора создать
отдельный NPM пакет и описать все возможности UI библиотеки в одном месте, и вот почему:

- Мы будем подключать этот пакет при инициализации нового репозитория, что позволит контролировать версию и упростит
  рефакторинг при обновлении
- Перестанем дублировать один и тот же код снова и снова.
- Объявления типов будут выступать в качестве дополнительной документации к UI компонентам. Ведь выбирать метод из
  подсказок **IntelliSense** гораздо удобнее, чем идти на сайт с описанием нужного компонента и копировать имя метода.

### Что Же Не Так?

Можно спросить, что же тут особенного? Дело в том, что мы добавляем на страницу глобальный объект для того, чтобы
использовать функционал UI библиотеки. То есть, она доступна глобально. В то же время, у нас есть наборы константных
значений (например для акцента кнопок, для цвета тегов или для типа клетки в таблице), которые мы используем в наших
приложениях. Обычно это набор заданных значений, используя который мы можем стилизовать тот или иной компонент.
Например, мы можем отрисовать один из несколько типов кнопок:

```typescript
// lists/button.ts

export enum ButtonType {
  Primary = "ui-primary",
  Secondary = "ui-secondary",
  Danger = "ui-danger"
}
```

(цвет, размер и шрифт кнопки зависят от значения, которое мы передали)

Было бы неплохо сложить все такие константы и списки значений в одно место с объявлениями типов. Выходит, что
результатом работы должен стать не просто файл с объявлением типов всех сущностей UI библиотеки, а целый пакет, который
бы полностью отображал состояние библиотеки на конкретный момент времени.
Объединяя все сказанное выше, наша цель состояла из трех пунктов:

1.  Глобальный объект `ui` должен быть доступен всегда без необходимости объявлять импорт библиотеки.
2.  Все типы из библиотеки должны быть доступны всегда без необходимости объявлять импорт библиотеки.
3.  Мы также хотим иметь возможность объявить импорт для констант и других доступных значений из UI библиотеки (не
    хранятся внутри глобальной переменной `ui`). В этом случае не должно быть никаких конфликтов с пунктами 1 и 2.

Кажется, что это несложно, ведь так? Мы просто создаем `d.ts` модуль, прописываем все объявления типов для нашей
библиотеки и... так, ок, мы не можем объявлять реальный код (константы, объекты и т.п.) внутри `d.ts` файлов. Хорошо.
Тогда мы создадим реальный Typescript модуль и положим все этим списки и интерфейсы туда. Затем, мы... как мы тогда
объявим нашу глобальную переменную?..

Я потратил день на поиски, но не смог найти подходящий пример для такого случая. StackOverflow переполнен вопросами
относительно концепта `.d.ts против .ts`, и ничего похожего на задачу, которую я решаю, найти не удалось. Всё, что
оставалось, это пойти читать официальную документацию и пробовать разные варианты. Вот что получилось в результате.

### Начнем С Нуля

Итак, у нас ничего нет. Начнем с того, чтобы напишем интерфейсы и списки значений для нашей библиотеки, как мы это
делаем всегда. Здесь и ниже я буду приводить примеры в упрощенном виде, так как в этой статье я делаю акцент на подходе
к объявлению типов, а не на конкретной реализации интерфейсов или enum-списков. Итак, представим, что наша библиотека
содержит компонент нотификации - это простое модельное окно с текстом и, может быть, кнопками. В таком случае, один из
вариантов описания такого окна может выглядеть следующим образом:

```typescript
// interfaces/notification.ts

import type { ButtonType } from "../lists/button";

export interface NotificationButtonConfig {
  text?: string;
  type?: ButtonType;
}

export interface Notification {
  info(text: string, buttons?: NotificationButtonConfig[]): void;
  warning(text: string, buttons?: NotificationButtonConfig[]): void;
  error(text: string, buttons?: NotificationButtonConfig[]): void;
}
```

(Мы описали объект с методами вызовы разных видов нотификаций, состоящих из текста и кнопок)

Мы используем enum-список `ButtonType`, который уже объявляли раньше:

```typescript
// lists/button.ts

export enum ButtonType {
  Primary = "ui-primary",
  Secondary = "ui-secondary",
  Danger = "ui-danger"
}
```

(мы подсвечиваем кнопку в определенном стиле в зависимости от типа)

Теперь давайте рассмотрим самый простой случай. Наша UI библиотека предоставляет API для работы с компонентами. Значит,
у нас должен быть доступ к глобальному объекту библиотеки без необходимости делать импорт чего-либо:

```typescript
// example/application/moduleNoImport.ts

ui.notification.info("Document has been saved!");
```

(мы вызываем модальное окно с текстом, `ui` здесь просто глобальный объект)

Как мы можем сделать объект `ui` доступным? Мы объявляем наш объект в глобальной области видимости:

```typescript
// index.ts

import { UiLib } from "./interfaces/ui";

declare global {
  let ui: UiLib;
}
```

(мы объявили новый глобальный объект)

Интерфейс `UiLib` здесь содержит описания для всего API, которое поддерживает наша UI библиотека. В нашем упрощенном
случае, здесь объявлены методы для отображения нотификаций на странице:

```typescript
// interfaces/ui.ts

import { Notification } from "./notification";

export interface UiLib {
  notification: Notification;
}
```

(разные типы уведомлений собраны в интерфейсе Notification, как мы могли увидеть выше)

И на этом можно закончить со случаем, который мы рассматриваем. Остается только настроить наш только что приготовленный
NPM пакет. Мы попросим Typescript разнести код и объявления типов в разные директории, а также явно укажем сохранять
объявления типов при компиляции в Javascript. Часть нашего `tsconfig.json` будет выглядеть следубщим образом:

```json
{
  "compilerOptions": {
    "declaration": true,
    "declarationDir": "dist/",
    "outDir": "dist/es"
  }
}
```

Последним шагом мы укажем правильные пути в нашем `package.json`:

```json
{
  "main": "dist/es/index.js",
  "types": "dist/index.d.ts"
}
```

(не забудьте добавить компиляцию из Typescript при публикации пакета)

Теперь точно все. Мы можем установить новый пакет в очередном репозитории, указать в `tsconfig.json` путь для
объявлений типов (так как наш npm пакет не попадем в директорию `@types`) и увидеть как всё работает!

### А Как Же Пользоваться Значениями?

Усложним задачу. У нас есть enum-список ButtonType и мы хотим им воспользоваться. Для этого нам нужно сделать импорт
значения, например вот так:

```typescript
// example/application/moduleWithImport.ts

import { UiCore } from "ui-types-package";

const showNotification = (message: string): void =>
  ui.notification.info(message, [
    { text: "OK", type: UiCore.ButtonType.Danger }
  ]);
```

(мы хотим показать модальное окно с большой красной кнопкой)

Отмечу, что здесь **UiCore** по факту является неймспейсом для всех констант, интерфейсов, списков — то есть для
всех сущностей, которые содержит и поддерживает наша UI библиотека. Таким образом, нам не нужно думать о том, как
назвать тот или иной интерфейс. `Notification` звучит очень абстрактно, и нужен префикс, чтобы понять, кому принадлежит
тот или иной объект. С другой стороны `UiCore.Notification` дает полное понимание принадлежности к библиотеке
компонентов. Создавать неймспейс необязательно, я нашел этот подход удобным для того, чтобы сгруппировать все вещи
в одно пространство имён.

На данный момент мы не может сделать импорт для `UiCore` из нашего пакета с типами. У нас просто нет экспорта. Исправим
этот момент. Для начала объявим неймспейс:

```typescript
// namespaces/core.ts

import * as notificationInterfaces from "../interfaces/notification";
import * as buttonLists from "../lists/button";

export namespace UiCore {
  export import NotificationButtonConfig = notificationInterfaces.NotificationButtonConfig;

  export import ButtonType = buttonLists.ButtonType;
}
```

(мы используем композитный оператор экспорта для того, чтобы создать псевдоним объекта внутри неймспейса)

Мы делаем экспорт всех доступных объектов внутри неймспейса с помощью синтаксиса `export import`. Всё что нам осталось
сделать, это дать доступ к нашему свежему неймспейсу извне. Для этого у нас уже есть главный модуль пакета `index.ts`.
Добавим в него одну строчку с экспортом `UiCore`:

```typescript
// index.ts

import { UiLib } from "./interfaces/ui";

export { UiCore } from "./namespaces/core";

declare global {
  let ui: UiLib;
}
```

(мы делаем экспорт UiCore и теперь он доступен для импорта в других проектах)

Два простых шага позволили нам добиться необходимого результата! Теперь мы можем сделать импорт UiCore в коде нашего
приложения и использовать все возможности UI компонентов нашей библиотеки. Или можем придумать варианты использования,
которые не покрыты нашей реализаций. Например, в нашем примере мы использовали значение `ButtonType.Danger`, чтобы
создать уведомление с кнопкой, окрашенной в красный цвет. Что, если мы захотим использовать `ButtonType` как тип
параметра для очередной функции? Мы можем сделать импорт UiCore. Но зачем?

### Закрываем Краевые Случаи

Мы не собираемся пользоваться каким-то определенным значение и будем использовать `UiCore.ButtonType` для объявления
типа параметров. Значит нет смысла объявлять импорт для `UiCore`. На данный момент такой способ не будет работать,
так как мы не добавили `UiCore` в глобальную область видимости. Например, мы не сможем написать такой метод:

```typescript
// example/application/moduleWithType.ts

const showNotificationWithButton = (
  buttonText: string,
  buttonType: UiCore.ButtonType
): void =>
  ui.notification.info("hello world!", [
    { text: buttonText, type: buttonType }
  ]);
```

(TS2503: Cannot find namespace 'UiCore')

Нам нужно объявить `UiCore` глобально. И здесь мы приходим к истории о том, что нельзя просто так взять существующий
неймспейс и сделать ре-экспорт в глобальной области видимости. Трюк заключается в том, что придется создать новый
неймспейс с таким же именем (в нашем случае `UiCore`) и объявить все объекты, которые мы собрали в одном месте, второй
раз. Хорошая новость в том, что необязательно собирать каждый интерфейс из отдельного модуля. Можно просто вывести
наш глобальный неймспейс из существующего:

```typescript
// index.ts

import { UiCore as _UiCore } from "./namespaces/core";
import { UiLib } from "./interfaces/ui";

export { _UiCore as UiCore };

declare global {
  namespace UiCore {
    export type NotificationButtonConfig = _UiCore.NotificationButtonConfig;

    export type ButtonType = _UiCore.ButtonType;
  }

  let ui: UiLib;
}
```

(мы создаем типы оъектов из существующего неймспейса с помощью оператора создания псевдонимов типа)

Первым шагом мы переименуем импорт `UiCore` для того, чтобы избежать конфликта имён. Далее мы поправим имя в экспорте
для того, чтобы всё осталось на своих местах. Наконец, мы создаем новый неймспейс в глобальной области видимости и
создаем псевдонимы типов для каждой сущности. Может показаться, что мы дублируем код. Отчасти это так, но на самом деле
мы получаем разные объекты:

```typescript
// UiCore в глобальной области видимости
export type ButtonType = buttonLists.ButtonType;

// UiCore, содержит ссылки на реальные значения
export import ButtonType = lButton.ButtonType;
```

(синтаксис отличается для каждого случая)

Неймспейс в глобальной области видимости использует синтаксис
[псевдонима типа](https://www.typescriptlang.org/docs/handbook/advanced-types.html#type-aliases).
Такой подход не работает, когда нам нужно использовать реальное значение переменной. Вместо этого, мы делаем экспорт
объектов в нашем реальном неймспейсе с помощью композитного оператора `export import`. Таким образом, мы собираем все
интерфейсы, константы, типы данных под одним именем. Всё API нашей Javascript собрано в одном месте и опыт использования
не зависит от того, объявит разработчик импорт или нет.

Такой трюк заставляет следить за тем, чтобы объявить очередной объект в двух местах. С другой стороны, это позволяет
покрыть все возможные варианты использования библиотеки типов в проекте. В результате разработчики получают готовые
объявления типа для UI компонентов и могут использовать API, как и в Javascript модулях без необходимости импорта
`UiCore`. Также отпадает необходимости создавать одни и те же константы снова и снова. Теперь все они собраны в одном
месте. Если вам нужна красная кнопка — вы объявляете импорт и присваиваете нужное значение. При этом остальной код
продолжает работать как обычно.
Мы создавали объявления типов на Typescript 3. В 4 версии появился специальный синтаксис, который работает похожим
способом и не противоречит нашей реализации. Вы можете написать `import type { UiCore } from "ui-types-package"` и
всё будет работать, как раньше.

### В Заключении

Вы можете найти тысячи примеров того, как создавать объявления типов для вашей Javascript библиотеки. Я постарался
рассказать редкий случай, когда необходимо создать не только объявления типов, но также реальные значения полей,
с которыми может работать API библиотеки. Неважно, используете вы глобальный объект или объявляете импорт для нужной
переменной — опыт работы с таки пакетом не изменится. Идея заключается в том, чтобы создать два похожих неймспейса:
неймспейс для экспорта, содержащий реальные переменные и данные, и глобальную копию с помощью оператора создания
псевдонима типов. Имена, указанные в статье, легко заменить на то, что нужно вам.

Полный код примеров можно найти [здесь](https://github.com/n0th1ng-else/typescript-types-complex-example).
